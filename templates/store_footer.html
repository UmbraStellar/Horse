<hr>


<h3>1. Что даёт генератор администраторской базы?</h3> 

<p>Генератор <a href="index.php?randomize=admin&mode=admin">администраторской базы</a> создаёт коллекцию рандомных карточек и сразу же переключает просмотр каталога в режим администратора. Карточки могут быть следующих видов:</p>

<ul>
	<li><b>Правильные</b> - видны клиенту в каталоге и доступны для заказа.</li>
	<li><b>Забронированные</b> - заказы на стадии выполнения (их сбросить и вернуть в каталог).</li>
	<li><b>Некорректные</b> - они неправильны с точки зрения бизнес-логики, описанной в модели и ожидают исправления.</li>
</ul>


<h3>2. Почему видно чужие оплаченные заказы?</h3> 

<p>Видимость сделана для теста, чтобы показать случай, когда кто-то уже опередил с заказом и нужно заблокировать оплату. В реальном примере чужие оплаченные заказы скрыты и видны только администратору. Можно попробовать синхронный тест, когда несколько человек попробуют заказать одну и ту же лошадь (перед этим кто-то один создаст рандомную базу и другие её не обновляют).</p>


<h3>3. Как работает фильтрация каталога?</h3> 

<p>Пользователь может кликать некоторые поля прямо в процессе сёрфинга каталога. У каждого поля свой тег-категория, для более логичной выдачи результата. Если вы находитесь в режиме администратора, фильтр пропускает также и некорректные и забронированные заказы, но в обычном режиме для клиента такие карточки скрыты.</p>


<h3>4. Как работают метрики каталога?</h3> 

<p>Функционал витрины в данной реализации - это по-сути симулятор потока информации, состоящего из случайного набора реальных данных для тестирования и отработки бизнес-логики модели при взаимодействии с интерфейсом.</p>

<p>Метрики обновляются после их подсчёта во время отображения каталога с учётом фильтрации и категоризации. В реальном проекте часть этих метрик хранится в базе (количество карточек, подписей и заказов), а часть может быть измерена в ходе запроса к БД перед рендером каталога, поэтому метрики будут отображаться в любой момент времени.</p>

<p>При генерации новой тестовой базы видна ощутимая задержка при обновлении метрик. Это связано с тем, что через секунду идёт переадресация на ту же страницу для сброса параметра рандомизации ("&randomize=client" или "&randomize=admin") и только потом обновляются метрики. Это не принципиально важно, так как генерировать случайную базу можно было через ajax без обновления страницы либо просто не очищать адресную строку методом переадресации. Но всегда забываешь что там стоит этот параметр и после некоторой активности в каталоге при обновлении генерировалась новая база. Это уже отдельная история, поэтому пока так.</p>


<h3>5. Почему возраст определяется месяцами, а не датой рождения?</h3> 

<p>В реальной жизни многие владельцы не всегда знают точную и настоящую дату рождения лошадей, если не разводят их сами. Эти лошади могли быть выкуплены без документов, а возраст мог быть примерным или ошибочным. В этой сфере существуют специальные методики оценки примерного возраста лошади по её анатомии. Поэтому я сделал вывод, что атомарное значение для возраста может быть указано в качестве месяцев.</p>

<p>При этом в системе учитывается дата публикации карточки, поэтому изначально указанный возраст будет всегда актуализироваться с учётом даты просмотра каталога. Но правильнее было бы предусмотреть ввод примерного возраста на фронтенде в формате (год + месяцы), а на бэкенде вычислять примерную дату рождения и хранить в базе именно её, вычисляя актуальный возраст при выдаче в каталог.
</p>


<h3>6. Как реализована модель?</h3> 

<p>Карточки в витрине - это потомки абстрактного класса в четвёртом поколении. Сборка сущностей реализована по принципу Фабрики с конвейерной сборкой, где каждый класс - это цех, который собирает только свою логическую часть финальной коммерческой сущности - лошади, как элемента каталога.</p>

<ul>
	<li>Абстрактный предок <b>Horse</b> описывает набор полей для двух следующих поколений с обязательным валидатором. Класс помогает понять с какой завершённой сущностью мы работаем. Текущий набор переменных для абстракции условен и может быть изменён в пользу удобства при масштабировании и поддержке.</li>
	<li>1-я цех конвейера <b>HorseAnatomy</b> отвечает за анатомию лошади (пол, возраст, вес, порода).</li>
	<li>2-я цех <b>HorseSocial</b> отвечает за социальные параметры лошади (имя, место рождения, характер, способности).</li>
	<li>3-я цех <b>HorseStore</b> отвечает за коммерческие параметры лошади (сервисы аренды/покупки, цены, статус заказа).</li>
</ul>

<p>Каждый цех фабрики знает как валидировать и форматировать свои данные. Связанность потомков с предками на пути конвейера реализована через конструктор, в котором потомок поручает предку сборку логической части сущности.</p>
 
<p>Модель абстрагирована от способов хранения и чтения данных и учитывает только бизнес-логику биржи в части взаимодействия клиента с конкретным объектом. Инициализация объектов производится в контроллере. Модель позволяет понимать корректность и доступность данных в контексте различных процессов / статусов / состояний / фильтров.</p>

<p>По умолчанию каждый цех фабрики валидирует свою сборку перед выходом из конструктора. Но для избежания избыточной валидации на каждом из этапов сборки предусмотрен сквозной параметр принудительного отключения валидации предков, чтобы делать это один раз в конечном потомке, который чаще всего используется.</p>


<h3>7. Как тестовый симулятор связан с моделью?</h3> 

<p>В данном стенде используются дополнительные тестовые классы симулятора - потомки основной модели. Они умеют по-своему хранить, читать и генерировать рандомные карточки без использования БД.</p>

<p>Объекты модели не знают о существовании тестовых классов симулятора, то есть в рамках своей собственной реализации с ними никак не связаны и не сцеплены. В чистовой реализации (когда информация будет храниться в БД) эти тестовые классы не будут использоваться, а процесс записи и чтения будет реализован в контроллере БД, а не средствами классов симулятора.</p>



</body>
</html>